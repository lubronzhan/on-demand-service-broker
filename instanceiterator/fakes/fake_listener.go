// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"github.com/lubronzhan/on-demand-service-broker/config"
	"github.com/lubronzhan/on-demand-service-broker/instanceiterator"
	"github.com/lubronzhan/on-demand-service-broker/service"
)

type FakeListener struct {
	CanariesFinishedStub        func()
	canariesFinishedMutex       sync.RWMutex
	canariesFinishedArgsForCall []struct {
	}
	CanariesStartingStub        func(int, config.CanarySelectionParams)
	canariesStartingMutex       sync.RWMutex
	canariesStartingArgsForCall []struct {
		arg1 int
		arg2 config.CanarySelectionParams
	}
	FailedToRefreshInstanceInfoStub        func(string)
	failedToRefreshInstanceInfoMutex       sync.RWMutex
	failedToRefreshInstanceInfoArgsForCall []struct {
		arg1 string
	}
	FinishedStub        func(int, int, int, int, []string, []string)
	finishedMutex       sync.RWMutex
	finishedArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 int
		arg5 []string
		arg6 []string
	}
	InstanceOperationFinishedStub        func(string, string)
	instanceOperationFinishedMutex       sync.RWMutex
	instanceOperationFinishedArgsForCall []struct {
		arg1 string
		arg2 string
	}
	InstanceOperationStartResultStub        func(string, instanceiterator.OperationState)
	instanceOperationStartResultMutex       sync.RWMutex
	instanceOperationStartResultArgsForCall []struct {
		arg1 string
		arg2 instanceiterator.OperationState
	}
	InstanceOperationStartingStub        func(string, int, int, bool)
	instanceOperationStartingMutex       sync.RWMutex
	instanceOperationStartingArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 bool
	}
	InstancesToProcessStub        func([]service.Instance)
	instancesToProcessMutex       sync.RWMutex
	instancesToProcessArgsForCall []struct {
		arg1 []service.Instance
	}
	ProgressStub        func(time.Duration, int, int, int, int, int)
	progressMutex       sync.RWMutex
	progressArgsForCall []struct {
		arg1 time.Duration
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 int
	}
	RetryAttemptStub        func(int, int)
	retryAttemptMutex       sync.RWMutex
	retryAttemptArgsForCall []struct {
		arg1 int
		arg2 int
	}
	RetryCanariesAttemptStub        func(int, int, int)
	retryCanariesAttemptMutex       sync.RWMutex
	retryCanariesAttemptArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 int
	}
	StartingStub        func(int)
	startingMutex       sync.RWMutex
	startingArgsForCall []struct {
		arg1 int
	}
	UpgradeStrategyStub        func(string)
	upgradeStrategyMutex       sync.RWMutex
	upgradeStrategyArgsForCall []struct {
		arg1 string
	}
	WaitingForStub        func(string, int)
	waitingForMutex       sync.RWMutex
	waitingForArgsForCall []struct {
		arg1 string
		arg2 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeListener) CanariesFinished() {
	fake.canariesFinishedMutex.Lock()
	fake.canariesFinishedArgsForCall = append(fake.canariesFinishedArgsForCall, struct {
	}{})
	fake.recordInvocation("CanariesFinished", []interface{}{})
	fake.canariesFinishedMutex.Unlock()
	if fake.CanariesFinishedStub != nil {
		fake.CanariesFinishedStub()
	}
}

func (fake *FakeListener) CanariesFinishedCallCount() int {
	fake.canariesFinishedMutex.RLock()
	defer fake.canariesFinishedMutex.RUnlock()
	return len(fake.canariesFinishedArgsForCall)
}

func (fake *FakeListener) CanariesFinishedCalls(stub func()) {
	fake.canariesFinishedMutex.Lock()
	defer fake.canariesFinishedMutex.Unlock()
	fake.CanariesFinishedStub = stub
}

func (fake *FakeListener) CanariesStarting(arg1 int, arg2 config.CanarySelectionParams) {
	fake.canariesStartingMutex.Lock()
	fake.canariesStartingArgsForCall = append(fake.canariesStartingArgsForCall, struct {
		arg1 int
		arg2 config.CanarySelectionParams
	}{arg1, arg2})
	fake.recordInvocation("CanariesStarting", []interface{}{arg1, arg2})
	fake.canariesStartingMutex.Unlock()
	if fake.CanariesStartingStub != nil {
		fake.CanariesStartingStub(arg1, arg2)
	}
}

func (fake *FakeListener) CanariesStartingCallCount() int {
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	return len(fake.canariesStartingArgsForCall)
}

func (fake *FakeListener) CanariesStartingCalls(stub func(int, config.CanarySelectionParams)) {
	fake.canariesStartingMutex.Lock()
	defer fake.canariesStartingMutex.Unlock()
	fake.CanariesStartingStub = stub
}

func (fake *FakeListener) CanariesStartingArgsForCall(i int) (int, config.CanarySelectionParams) {
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	argsForCall := fake.canariesStartingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) FailedToRefreshInstanceInfo(arg1 string) {
	fake.failedToRefreshInstanceInfoMutex.Lock()
	fake.failedToRefreshInstanceInfoArgsForCall = append(fake.failedToRefreshInstanceInfoArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FailedToRefreshInstanceInfo", []interface{}{arg1})
	fake.failedToRefreshInstanceInfoMutex.Unlock()
	if fake.FailedToRefreshInstanceInfoStub != nil {
		fake.FailedToRefreshInstanceInfoStub(arg1)
	}
}

func (fake *FakeListener) FailedToRefreshInstanceInfoCallCount() int {
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	return len(fake.failedToRefreshInstanceInfoArgsForCall)
}

func (fake *FakeListener) FailedToRefreshInstanceInfoCalls(stub func(string)) {
	fake.failedToRefreshInstanceInfoMutex.Lock()
	defer fake.failedToRefreshInstanceInfoMutex.Unlock()
	fake.FailedToRefreshInstanceInfoStub = stub
}

func (fake *FakeListener) FailedToRefreshInstanceInfoArgsForCall(i int) string {
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	argsForCall := fake.failedToRefreshInstanceInfoArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) Finished(arg1 int, arg2 int, arg3 int, arg4 int, arg5 []string, arg6 []string) {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	var arg6Copy []string
	if arg6 != nil {
		arg6Copy = make([]string, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.finishedMutex.Lock()
	fake.finishedArgsForCall = append(fake.finishedArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 int
		arg4 int
		arg5 []string
		arg6 []string
	}{arg1, arg2, arg3, arg4, arg5Copy, arg6Copy})
	fake.recordInvocation("Finished", []interface{}{arg1, arg2, arg3, arg4, arg5Copy, arg6Copy})
	fake.finishedMutex.Unlock()
	if fake.FinishedStub != nil {
		fake.FinishedStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
}

func (fake *FakeListener) FinishedCallCount() int {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	return len(fake.finishedArgsForCall)
}

func (fake *FakeListener) FinishedCalls(stub func(int, int, int, int, []string, []string)) {
	fake.finishedMutex.Lock()
	defer fake.finishedMutex.Unlock()
	fake.FinishedStub = stub
}

func (fake *FakeListener) FinishedArgsForCall(i int) (int, int, int, int, []string, []string) {
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	argsForCall := fake.finishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeListener) InstanceOperationFinished(arg1 string, arg2 string) {
	fake.instanceOperationFinishedMutex.Lock()
	fake.instanceOperationFinishedArgsForCall = append(fake.instanceOperationFinishedArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("InstanceOperationFinished", []interface{}{arg1, arg2})
	fake.instanceOperationFinishedMutex.Unlock()
	if fake.InstanceOperationFinishedStub != nil {
		fake.InstanceOperationFinishedStub(arg1, arg2)
	}
}

func (fake *FakeListener) InstanceOperationFinishedCallCount() int {
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	return len(fake.instanceOperationFinishedArgsForCall)
}

func (fake *FakeListener) InstanceOperationFinishedCalls(stub func(string, string)) {
	fake.instanceOperationFinishedMutex.Lock()
	defer fake.instanceOperationFinishedMutex.Unlock()
	fake.InstanceOperationFinishedStub = stub
}

func (fake *FakeListener) InstanceOperationFinishedArgsForCall(i int) (string, string) {
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	argsForCall := fake.instanceOperationFinishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) InstanceOperationStartResult(arg1 string, arg2 instanceiterator.OperationState) {
	fake.instanceOperationStartResultMutex.Lock()
	fake.instanceOperationStartResultArgsForCall = append(fake.instanceOperationStartResultArgsForCall, struct {
		arg1 string
		arg2 instanceiterator.OperationState
	}{arg1, arg2})
	fake.recordInvocation("InstanceOperationStartResult", []interface{}{arg1, arg2})
	fake.instanceOperationStartResultMutex.Unlock()
	if fake.InstanceOperationStartResultStub != nil {
		fake.InstanceOperationStartResultStub(arg1, arg2)
	}
}

func (fake *FakeListener) InstanceOperationStartResultCallCount() int {
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	return len(fake.instanceOperationStartResultArgsForCall)
}

func (fake *FakeListener) InstanceOperationStartResultCalls(stub func(string, instanceiterator.OperationState)) {
	fake.instanceOperationStartResultMutex.Lock()
	defer fake.instanceOperationStartResultMutex.Unlock()
	fake.InstanceOperationStartResultStub = stub
}

func (fake *FakeListener) InstanceOperationStartResultArgsForCall(i int) (string, instanceiterator.OperationState) {
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	argsForCall := fake.instanceOperationStartResultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) InstanceOperationStarting(arg1 string, arg2 int, arg3 int, arg4 bool) {
	fake.instanceOperationStartingMutex.Lock()
	fake.instanceOperationStartingArgsForCall = append(fake.instanceOperationStartingArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("InstanceOperationStarting", []interface{}{arg1, arg2, arg3, arg4})
	fake.instanceOperationStartingMutex.Unlock()
	if fake.InstanceOperationStartingStub != nil {
		fake.InstanceOperationStartingStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeListener) InstanceOperationStartingCallCount() int {
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	return len(fake.instanceOperationStartingArgsForCall)
}

func (fake *FakeListener) InstanceOperationStartingCalls(stub func(string, int, int, bool)) {
	fake.instanceOperationStartingMutex.Lock()
	defer fake.instanceOperationStartingMutex.Unlock()
	fake.InstanceOperationStartingStub = stub
}

func (fake *FakeListener) InstanceOperationStartingArgsForCall(i int) (string, int, int, bool) {
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	argsForCall := fake.instanceOperationStartingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeListener) InstancesToProcess(arg1 []service.Instance) {
	var arg1Copy []service.Instance
	if arg1 != nil {
		arg1Copy = make([]service.Instance, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.instancesToProcessMutex.Lock()
	fake.instancesToProcessArgsForCall = append(fake.instancesToProcessArgsForCall, struct {
		arg1 []service.Instance
	}{arg1Copy})
	fake.recordInvocation("InstancesToProcess", []interface{}{arg1Copy})
	fake.instancesToProcessMutex.Unlock()
	if fake.InstancesToProcessStub != nil {
		fake.InstancesToProcessStub(arg1)
	}
}

func (fake *FakeListener) InstancesToProcessCallCount() int {
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	return len(fake.instancesToProcessArgsForCall)
}

func (fake *FakeListener) InstancesToProcessCalls(stub func([]service.Instance)) {
	fake.instancesToProcessMutex.Lock()
	defer fake.instancesToProcessMutex.Unlock()
	fake.InstancesToProcessStub = stub
}

func (fake *FakeListener) InstancesToProcessArgsForCall(i int) []service.Instance {
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	argsForCall := fake.instancesToProcessArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) Progress(arg1 time.Duration, arg2 int, arg3 int, arg4 int, arg5 int, arg6 int) {
	fake.progressMutex.Lock()
	fake.progressArgsForCall = append(fake.progressArgsForCall, struct {
		arg1 time.Duration
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 int
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("Progress", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.progressMutex.Unlock()
	if fake.ProgressStub != nil {
		fake.ProgressStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
}

func (fake *FakeListener) ProgressCallCount() int {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	return len(fake.progressArgsForCall)
}

func (fake *FakeListener) ProgressCalls(stub func(time.Duration, int, int, int, int, int)) {
	fake.progressMutex.Lock()
	defer fake.progressMutex.Unlock()
	fake.ProgressStub = stub
}

func (fake *FakeListener) ProgressArgsForCall(i int) (time.Duration, int, int, int, int, int) {
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	argsForCall := fake.progressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeListener) RetryAttempt(arg1 int, arg2 int) {
	fake.retryAttemptMutex.Lock()
	fake.retryAttemptArgsForCall = append(fake.retryAttemptArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("RetryAttempt", []interface{}{arg1, arg2})
	fake.retryAttemptMutex.Unlock()
	if fake.RetryAttemptStub != nil {
		fake.RetryAttemptStub(arg1, arg2)
	}
}

func (fake *FakeListener) RetryAttemptCallCount() int {
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	return len(fake.retryAttemptArgsForCall)
}

func (fake *FakeListener) RetryAttemptCalls(stub func(int, int)) {
	fake.retryAttemptMutex.Lock()
	defer fake.retryAttemptMutex.Unlock()
	fake.RetryAttemptStub = stub
}

func (fake *FakeListener) RetryAttemptArgsForCall(i int) (int, int) {
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	argsForCall := fake.retryAttemptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) RetryCanariesAttempt(arg1 int, arg2 int, arg3 int) {
	fake.retryCanariesAttemptMutex.Lock()
	fake.retryCanariesAttemptArgsForCall = append(fake.retryCanariesAttemptArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("RetryCanariesAttempt", []interface{}{arg1, arg2, arg3})
	fake.retryCanariesAttemptMutex.Unlock()
	if fake.RetryCanariesAttemptStub != nil {
		fake.RetryCanariesAttemptStub(arg1, arg2, arg3)
	}
}

func (fake *FakeListener) RetryCanariesAttemptCallCount() int {
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	return len(fake.retryCanariesAttemptArgsForCall)
}

func (fake *FakeListener) RetryCanariesAttemptCalls(stub func(int, int, int)) {
	fake.retryCanariesAttemptMutex.Lock()
	defer fake.retryCanariesAttemptMutex.Unlock()
	fake.RetryCanariesAttemptStub = stub
}

func (fake *FakeListener) RetryCanariesAttemptArgsForCall(i int) (int, int, int) {
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	argsForCall := fake.retryCanariesAttemptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeListener) Starting(arg1 int) {
	fake.startingMutex.Lock()
	fake.startingArgsForCall = append(fake.startingArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Starting", []interface{}{arg1})
	fake.startingMutex.Unlock()
	if fake.StartingStub != nil {
		fake.StartingStub(arg1)
	}
}

func (fake *FakeListener) StartingCallCount() int {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	return len(fake.startingArgsForCall)
}

func (fake *FakeListener) StartingCalls(stub func(int)) {
	fake.startingMutex.Lock()
	defer fake.startingMutex.Unlock()
	fake.StartingStub = stub
}

func (fake *FakeListener) StartingArgsForCall(i int) int {
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	argsForCall := fake.startingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) UpgradeStrategy(arg1 string) {
	fake.upgradeStrategyMutex.Lock()
	fake.upgradeStrategyArgsForCall = append(fake.upgradeStrategyArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UpgradeStrategy", []interface{}{arg1})
	fake.upgradeStrategyMutex.Unlock()
	if fake.UpgradeStrategyStub != nil {
		fake.UpgradeStrategyStub(arg1)
	}
}

func (fake *FakeListener) UpgradeStrategyCallCount() int {
	fake.upgradeStrategyMutex.RLock()
	defer fake.upgradeStrategyMutex.RUnlock()
	return len(fake.upgradeStrategyArgsForCall)
}

func (fake *FakeListener) UpgradeStrategyCalls(stub func(string)) {
	fake.upgradeStrategyMutex.Lock()
	defer fake.upgradeStrategyMutex.Unlock()
	fake.UpgradeStrategyStub = stub
}

func (fake *FakeListener) UpgradeStrategyArgsForCall(i int) string {
	fake.upgradeStrategyMutex.RLock()
	defer fake.upgradeStrategyMutex.RUnlock()
	argsForCall := fake.upgradeStrategyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeListener) WaitingFor(arg1 string, arg2 int) {
	fake.waitingForMutex.Lock()
	fake.waitingForArgsForCall = append(fake.waitingForArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("WaitingFor", []interface{}{arg1, arg2})
	fake.waitingForMutex.Unlock()
	if fake.WaitingForStub != nil {
		fake.WaitingForStub(arg1, arg2)
	}
}

func (fake *FakeListener) WaitingForCallCount() int {
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	return len(fake.waitingForArgsForCall)
}

func (fake *FakeListener) WaitingForCalls(stub func(string, int)) {
	fake.waitingForMutex.Lock()
	defer fake.waitingForMutex.Unlock()
	fake.WaitingForStub = stub
}

func (fake *FakeListener) WaitingForArgsForCall(i int) (string, int) {
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	argsForCall := fake.waitingForArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeListener) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.canariesFinishedMutex.RLock()
	defer fake.canariesFinishedMutex.RUnlock()
	fake.canariesStartingMutex.RLock()
	defer fake.canariesStartingMutex.RUnlock()
	fake.failedToRefreshInstanceInfoMutex.RLock()
	defer fake.failedToRefreshInstanceInfoMutex.RUnlock()
	fake.finishedMutex.RLock()
	defer fake.finishedMutex.RUnlock()
	fake.instanceOperationFinishedMutex.RLock()
	defer fake.instanceOperationFinishedMutex.RUnlock()
	fake.instanceOperationStartResultMutex.RLock()
	defer fake.instanceOperationStartResultMutex.RUnlock()
	fake.instanceOperationStartingMutex.RLock()
	defer fake.instanceOperationStartingMutex.RUnlock()
	fake.instancesToProcessMutex.RLock()
	defer fake.instancesToProcessMutex.RUnlock()
	fake.progressMutex.RLock()
	defer fake.progressMutex.RUnlock()
	fake.retryAttemptMutex.RLock()
	defer fake.retryAttemptMutex.RUnlock()
	fake.retryCanariesAttemptMutex.RLock()
	defer fake.retryCanariesAttemptMutex.RUnlock()
	fake.startingMutex.RLock()
	defer fake.startingMutex.RUnlock()
	fake.upgradeStrategyMutex.RLock()
	defer fake.upgradeStrategyMutex.RUnlock()
	fake.waitingForMutex.RLock()
	defer fake.waitingForMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeListener) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ instanceiterator.Listener = new(FakeListener)
